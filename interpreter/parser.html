<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Parser - Vondel Language and Microarchitecture</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../interpreter/index.html"><strong aria-hidden="true">1.</strong> Interpreter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../interpreter/language.html"><strong aria-hidden="true">1.1.</strong> Language Specification</a></li><li class="chapter-item expanded "><a href="../interpreter/lexer.html"><strong aria-hidden="true">1.2.</strong> Lexer</a></li><li class="chapter-item expanded "><a href="../interpreter/parser.html" class="active"><strong aria-hidden="true">1.3.</strong> Parser</a></li><li class="chapter-item expanded "><a href="../interpreter/object.html"><strong aria-hidden="true">1.4.</strong> Object</a></li><li class="chapter-item expanded "><a href="../interpreter/environment.html"><strong aria-hidden="true">1.5.</strong> Environment</a></li><li class="chapter-item expanded "><a href="../interpreter/evaluator/index.html"><strong aria-hidden="true">1.6.</strong> Evaluator</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../interpreter/evaluator/rust.html"><strong aria-hidden="true">1.6.1.</strong> Rust</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.6.2.</strong> Custom Draft</div></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../assembler/index.html"><strong aria-hidden="true">2.</strong> Assembler</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../assembler/specs.html"><strong aria-hidden="true">2.1.</strong> Language Specification</a></li><li class="chapter-item expanded "><a href="../assembler/lexer.html"><strong aria-hidden="true">2.2.</strong> Lexer</a></li><li class="chapter-item expanded "><a href="../assembler/parser.html"><strong aria-hidden="true">2.3.</strong> Parser</a></li><li class="chapter-item expanded "><a href="../assembler/evaluator.html"><strong aria-hidden="true">2.4.</strong> Evaluator</a></li><li class="chapter-item expanded "><a href="../assembler/comparision.html"><strong aria-hidden="true">2.5.</strong> Comparision</a></li></ol></li><li class="chapter-item expanded "><a href="../uarch/index.html"><strong aria-hidden="true">3.</strong> UArch</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../uarch/uinstruction.html"><strong aria-hidden="true">3.1.</strong> Microinstruction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../uarch/implementations.html"><strong aria-hidden="true">3.1.1.</strong> Implementations</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../chapter_1.html"><strong aria-hidden="true">4.</strong> Comparision with Requested UArch</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Vondel Language and Microarchitecture</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/thewillyan/vondel" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="parser-design-decisions"><a class="header" href="#parser-design-decisions">Parser Design Decisions</a></h1>
<p>The Vondel parser is designed to parse the Vondel programming language, which is built on top of the Monkey language.
The parser follows the Pratt parsing approach to handle expressions and statements in the program.</p>
<h2 id="pratt-parser-explanation"><a class="header" href="#pratt-parser-explanation">Pratt Parser Explanation</a></h2>
<p>Pratt parsing, also known as TDOP, is a parsing technique that uses a Recursive Descent Approach to parse expressions based on their precedence and associativity.</p>
<p>The main idea behind Pratt parsing is to associate each token or operator with two parsing functions: a prefix parsing function and an infix parsing function.
The prefix parsing function is responsible for parsing expressions that start with the token, while the infix parsing function handles expressions that involve the token as an operator.</p>
<p>Let's illustrate how that bitch works with this simple expression <code>(-5 + 3) * 2</code></p>
<ol>
<li>
<p><strong>Tokenization</strong>:
The expression is tokenized as follows:
<code>(</code>, <code>-</code>, <code>5</code>, <code>+</code>, <code>3</code>, <code>)</code>, <code>*</code>, <code>2</code></p>
</li>
<li>
<p><strong>Precedence and Associativity</strong>:
Let's assign the following precedence levels:
<code>*</code> (highest), <code>+</code> (lower), <code>-</code> (lower)</p>
</li>
<li>
<p><strong>Prefix Parsing</strong>:
The prefix parsing function for the <code>(</code> token creates a grouping expression.</p>
</li>
<li>
<p><strong>Prefix Parsing for <code>-</code></strong>:
The parser encounters the <code>-</code> token and checks if it's a prefix operator. Since it is, the parser creates a unary expression for it.</p>
</li>
<li>
<p><strong>Infix Parsing</strong>:
The parser encounters the <code>)</code> token and skips it since it doesn't have an associated infix parsing function.</p>
</li>
<li>
<p><strong>Right Binding Power</strong>:
The right binding power for <code>*</code> is the same as its precedence level.</p>
</li>
<li>
<p><strong>Right-hand Side Expression</strong>:
The parser invokes the infix parsing function for <code>*</code> and creates a binary expression with the <code>*</code> operator and the right-hand side expression.</p>
</li>
<li>
<p><strong>Recursive Descent</strong>:
The parser examines the next token (<code>2</code>) and creates an integer expression for it.</p>
</li>
<li>
<p><strong>Parsing Complete</strong>:
The parsing process is complete, resulting in a fully parsed expression.</p>
</li>
</ol>
<p>Here's the visualization of the Pratt parsing process for the expression <code>(-5 + 3) * 2</code>:</p>
<pre><code>       *
      / \
     +   2
    / \
   -   3
    |
   5
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The parser uses the <code>anyhow</code> crate for error handling. It defines a custom <code>ParserError</code> enum to represent different parsing errors that can occur.
The <code>ErrorWithCtx</code> struct is used to associate the error message with the corresponding context in the source code.</p>
<h2 id="precedence"><a class="header" href="#precedence">Precedence</a></h2>
<p>The parser defines the Precedence enum to represent the precedence levels of different operators in the language.
The <code>precedence_of</code> function assigns a precedence level to each token type used in Pratt parsing.</p>
<h2 id="statement-types"><a class="header" href="#statement-types">Statement Types</a></h2>
<p>The parser defines the <code>StatementType</code> enum to represent different types of statements in the program.
This includes <code>Let statements</code> for variable declarations, <code>Return statements</code>, <code>Expression statements</code>, and <code>Block statements</code> for code blocks.</p>
<h2 id="expression"><a class="header" href="#expression">Expression</a></h2>
<p>The <code>Expression</code> module provides the definition and functionality for handling different types of expressions in the code.</p>
<h3 id="prefixop"><a class="header" href="#prefixop">PrefixOp</a></h3>
<p>The <code>PrefixOp</code> enum represents the prefix operators available in the language, including <code>Bang</code> and <code>Minus</code>.</p>
<h3 id="infixop"><a class="header" href="#infixop">InfixOp</a></h3>
<p>The <code>InfixOp</code> enum represents the infix operators available in the language, such as <code>Plus</code>, <code>Minus</code>, <code>Asterisk</code>, <code>Slash</code>, <code>Equal</code>, <code>NotEqual</code>, <code>LessThan</code>, and <code>GreaterThan</code>. It provides methods to retrieve the operator as a string representation.</p>
<h3 id="expression-1"><a class="header" href="#expression-1">Expression</a></h3>
<p>The <code>Expression</code> enum represents various types of expressions, including <code>Identifier</code>, <code>Integer</code>, <code>Prefix</code>, <code>Infix</code>, <code>Boolean</code>, <code>If</code>, <code>FunctionLiteral</code>, and <code>Call</code>. It also provides methods to get the type of the expression as a string and constructors for creating specific types of expressions.</p>
<h4 id="constructors"><a class="header" href="#constructors">Constructors</a></h4>
<ul>
<li><code>new_ident(ident: &amp;String)</code>: Creates a new <code>Identifier</code> expression with the given identifier.</li>
<li><code>new_integer(int: &amp;String) -&gt; Result&lt;Self&gt;</code>: Creates a new <code>Integer</code> expression with the parsed integer value from the input string. Returns an error if the parsing fails.</li>
<li><code>new_prefix(op: &amp;TokenType, exp: Expression) -&gt; Result&lt;Self&gt;</code>: Creates a new <code>Prefix</code> expression with the specified operator and right-hand side expression. Returns an error if the operator is not allowed.</li>
<li><code>new_infix(left: Expression, op: &amp;TokenType, right: Expression) -&gt; Result&lt;Self&gt;</code>: Creates a new <code>Infix</code> expression with the specified left-hand side, operator, and right-hand side expressions. Returns an error if the operator is not allowed.</li>
<li><code>new_boolean(t: &amp;TokenType) -&gt; Result&lt;Self&gt;</code>: Creates a new <code>Boolean</code> expression with the specified boolean value. Returns an error if the boolean token is not allowed.</li>
<li><code>new_if(cond: Expression, cons: StatementType, alt: Option&lt;StatementType&gt;)</code>: Creates a new <code>If</code> expression with the condition, consequence, and optional alternative statements.</li>
<li><code>new_function(params: Vec&lt;Expression&gt;, block: StatementType)</code>: Creates a new <code>FunctionLiteral</code> expression with the specified parameters and block statement.</li>
<li><code>new_call(func: Expression, args: Vec&lt;Expression&gt;)</code>: Creates a new <code>Call</code> expression with the specified function expression and argument expressions.</li>
</ul>
<h2 id="program-structure"><a class="header" href="#program-structure">Program Structure</a></h2>
<p>The parser uses the <code>Program</code> struct to store the parsed statements and errors. The <code>get_deez_program</code> method is responsible for parsing the entire program and populating the <code>Program</code> struct.</p>
<h2 id="lexer-integration"><a class="header" href="#lexer-integration">Lexer Integration</a></h2>
<p>The parser expects a slice of <code>TokenType</code> tokens as input, which are generated by a lexer. This allow us to do some kind of decoupling between lexing and parsing.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To use the parser follow these steps:</p>
<ol>
<li>
<p>Create a vector of tokens by hand or using a <a href="/docs/src/interpreter/lexer.html">lexer</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let input =  &quot;let tubias = 123;&quot;
let toks = Lexer::new(input).get_deez_tokens();
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Create a new <code>Parser</code> and pass this tokens as parameters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut parser = Parser::new(&amp;toks);
let program = parser.get_deez_program();
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Do whatever you want with these statements or errors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Access the parsed statements and handle errors if needed
for statement in program.statements {
    // Process each statement...
}

// Handle parsing errors, if any
for error in program.errors {
    // Handle each error...
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>The approach for testing this parser was decoupling it from the lexer. So that future internal changes of the current lexer can't interfere with our parse,
unless we change the contract between then that is <code>TokenType</code></p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In conclusion, the Vondel parser, based on the Pratt parsing approach, provides efficient and accurate parsing of expressions and statements in the Vondel programming language.
With its error handling capabilities, well-defined precedence levels, and support for various statement types,
the parser offers a solid foundation for the development and expansion of the Vondel language, ensuring reliable and effective parsing of code structures.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../interpreter/lexer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../interpreter/object.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../interpreter/lexer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../interpreter/object.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
